import "../utils/index.ostw";

class Mob {
	private define CoinsOnKill;
	private define TrinketOnKill;
	private define EnergyOnKill;
	private define CoreDamage;
	private define SpawnMessage;
	private define DamageDealt;
	private define MaxHealth;
	private define MoveSpeed;
	private define HeroMob;
	private define EXPOnKill;
	private define AutoUltChance;
	private define AutoPrimaryAtkChance;
	private define AutoSecondaryAtkChance;
	private define AutoAbility1Chance;
	private define AutoAbility2Chance;
	private define HoldPrimaryFire;
	private define HoldSecondaryFire;
	public define AttackDuringUlt;
	public define AttackInterval;
	
	public Mob(ref define heroMob, ref define coinsOnKill, ref define trinketOnKill,
				ref define energyOnKill, ref define expOnKill,
				ref define spawnMessage,
				ref define coreDamage, ref define damageDealt, ref define maxHealth, ref define moveSpeed,
				ref define autoUltChance, ref define autoPrimaryAtkChance, ref define autoSecondaryAtkChance,
				ref define autoAbility1Chance, ref define autoAbility2Chance,
				ref define attackDuringUlt, ref define holdPrimaryFire, ref define holdSecondaryFire, ref define attackInterval)
	{
		HeroMob = heroMob;
		CoinsOnKill = coinsOnKill;
		TrinketOnKill = trinketOnKill;
		EnergyOnKill = energyOnKill;
		CoreDamage = coreDamage;
		SpawnMessage = spawnMessage;
		DamageDealt = damageDealt;
		MaxHealth = maxHealth;
		MoveSpeed = moveSpeed;
		AutoUltChance = autoUltChance;
		AutoPrimaryAtkChance = autoPrimaryAtkChance;
		AutoSecondaryAtkChance = autoSecondaryAtkChance;
		AutoAbility1Chance = autoAbility1Chance;
		AutoAbility2Chance = autoAbility2Chance;
		AttackDuringUlt = attackDuringUlt;
		AttackInterval = attackInterval;
		HoldPrimaryFire = holdPrimaryFire;
		HoldSecondaryFire = holdSecondaryFire;
		EXPOnKill = expOnKill;
	}

	public void handleDead()
	{
		root.playerItr[SlotOf(root.Player)] = 0;
		while (root.playerItr[SlotOf(root.Player)] < CountOf(AllPlayers(Team.Team2)))
		{
			define aPlayer = AllPlayers(Team.Team2)[root.playerItr[SlotOf(root.Player)]];
			MinWait();

			define _chillingMobRewardModifier = aPlayer.ChillModeEnabled ? 0.5 : 1;
			aPlayer._MobVars[0] = RoundToInteger(RandomInteger(EXPOnKill * 0.9, EXPOnKill * 1.1) * aPlayer.EXPGainRate * (1 + (aPlayer.PlayerLevel / 50)), Rounding.Nearest);
			aPlayer._MobVars[1] = RoundToInteger(RandomInteger(CoinsOnKill * 0.8, CoinsOnKill * 1.2) * aPlayer.CoinGainRate  * _chillingMobRewardModifier * root.CoinsOnKillMultiplier, Rounding.Nearest);
			// aPlayer._MobVars[2] = RoundToInteger(root.Item_TrinketModifier * TrinketOnKill * aPlayer.TrinketGainRate * _chillingMobRewardModifier, Rounding.Nearest);
			aPlayer._MobVars[2] = 1;
			MinWait();

			aPlayer.EXP += aPlayer._MobVars[0];
			aPlayer.Coins += aPlayer._MobVars[1];
			aPlayer.Item_Trinket += aPlayer._MobVars[2];

			root.playerItr[SlotOf(root.Player)] += 1;
			MinWait();
		}

		PlayEffect(AllPlayers(Team.Team2), PlayEffect.BadPickupEffect, Color.Red, PositionOf(root.Player), 2);
		root.EnergyPoints += EnergyOnKill * root.EnergyMultiplier;
		root.MobKills += 1;
		if (root.CurrentQuest == 2) {
			root.CurrentQuestKills += 1;
		}
		
		if (root.MobLootWorldText[SlotOf(root.Player)] > 0) {
			DestroyInWorldText(root.MobLootWorldText[SlotOf(root.Player)]);
		}

		CreateInWorldText(
			AllPlayers(Team.Team2),
				<"+<0> XP & +<1> Coins & +<2> Trinkets",
				AllPlayers(Team.Team2)._MobVars[0],
				AllPlayers(Team.Team2)._MobVars[1],
				AllPlayers(Team.Team2)._MobVars[2]
			>,
			PositionOf(EvaluateOnce(root.Player) + Vector(0, (RandomInteger(1, 15) / 10), 0)), 1.2, Clipping.DoNotClip, InworldTextRev.VisibleTo, Color.Yellow, Spectators.DefaultVisibility);
		root.MobLootWorldText[SlotOf(root.Player)] = LastTextID();

		Wait(3, WaitBehavior.IgnoreCondition);
		DestroyInWorldText(root.MobLootWorldText[SlotOf(root.Player)]);
	}

	public void despawn(ref define mob)
	{
		Kill(mob, null);
		PlayEffect(AllPlayers(Team.All), PlayEffect.ExplosionSound, Color.White, mob, 100);
		
		if (root.CurrentQuest == 1 && root.CoreHealth > 0) {
			root.CoreHealth -= 1;
		}
	}

	public void spawn()
	{
		DestroyAllDummyBots();
		BigMessage(AllPlayers(Team.All), <"<0>s defeated! Next wave in <1> seconds.", HeroMob, root.BreakTime>);
		Wait(root.BreakTime, WaitBehavior.AbortWhenFalse);
		root.IsBreakTime = false;
		root.MobKills = 0;
		BigMessage(AllPlayers(Team.All), SpawnMessage);
		CreateDummyBot(HeroMob, Team.Team1, 0, Vector(0, 0, 0), Vector(0, 0, 0));
		CreateDummyBot(HeroMob, Team.Team1, 1, Vector(0, 0, 0), Vector(0, 0, 0));
		CreateDummyBot(HeroMob, Team.Team1, 2, Vector(0, 0, 0), Vector(0, 0, 0));
		CreateDummyBot(HeroMob, Team.Team1, 3, Vector(0, 0, 0), Vector(0, 0, 0));
		CreateDummyBot(HeroMob, Team.Team1, 4, Vector(0, 0, 0), Vector(0, 0, 0));
		Wait(1, WaitBehavior.IgnoreCondition);
		define playerCount = CountOf(AllPlayers(Team.Team2));
		define totalPlayerLevel = 0;
		for (define i = 0; i < playerCount; i++) {
			totalPlayerLevel += AllPlayers(Team.Team2)[i].PlayerLevel;
		}
		root.UpdateAveragePlayerLevel();
		AllPlayers(Team.Team1).PlayerLevel = root.AveragePlayerLevel;
		define MobLevelModifier = 1 + (root.AveragePlayerLevel * 0.4);
		SetHealingReceived(PlayersOnHero(HeroMob, Team.Team1), 0);
		SetMaxHealth(PlayersOnHero(HeroMob, Team.Team1), MobLevelModifier * root.DifficultyModifier * root.MobHealthModifier * NumberOfPlayers(Team.Team2) * MaxHealth);
		MinWait();
		SetPlayerHealth(PlayersOnHero(HeroMob, Team.Team1), MobLevelModifier * root.DifficultyModifier * root.MobHealthModifier * NumberOfPlayers(Team.Team2) * MaxHealth);
		SetDamageDealt(PlayersOnHero(HeroMob, Team.Team1), MobLevelModifier * root.DifficultyModifier * root.MobDamageModifier * DamageDealt);
		SetMoveSpeed(PlayersOnHero(HeroMob, Team.Team1), MobLevelModifier * root.MobSpeedModifier * MoveSpeed);
	}

	public void respawn()
	{
		Wait(root.MobRespawnTime, WaitBehavior.IgnoreCondition);
		root.UpdateAveragePlayerLevel();
		define MobLevelModifier = 1 + (root.AveragePlayerLevel * 0.4);
		SetMaxHealth(root.Player, MobLevelModifier * root.DifficultyModifier * root.MobHealthModifier * NumberOfPlayers(Team.Team2) * MaxHealth);
		MinWait();
		SetPlayerHealth(root.Player, MaxHealth(root.Player));
		SetDamageDealt(root.Player, MobLevelModifier * root.DifficultyModifier * root.MobDamageModifier * DamageDealt);
		SetMoveSpeed(root.Player, (MobLevelModifier / 2) * root.MobSpeedModifier * MoveSpeed);
		root.Player.PlayerLevel = root.AveragePlayerLevel;
	}

	public void attack(ref define mob)
	{
		define randomChance = RandomInteger(1, 100);
		Wait(0.1, WaitBehavior.IgnoreCondition);
	
		if (AutoUltChance != false && randomChance <= AutoUltChance && IsUsingUltimate(mob) != true) {
			SetUltimateCharge(mob, 100);
			Wait(0.1, WaitBehavior.IgnoreCondition);
			PressButton(mob, Button.Ultimate);
		}

		if (IsUsingUltimate(mob)) {
			if (HeroOf(mob) == Hero.Mccree || HeroOf(mob) == Hero.Junkrat) {
				Wait(RandomInteger(2, 5), WaitBehavior.AbortWhenFalse);
			} 
			StartHoldingButton(mob, Button.PrimaryFire);
			Wait(2, WaitBehavior.IgnoreCondition);
			StopHoldingButton(mob, Button.PrimaryFire);
			
			if (IsUsingUltimate(mob)) {
				LoopIfConditionIsTrue();
			}
		}

		if (AutoAbility1Chance != false && randomChance <= AutoAbility1Chance) {
			PressButton(mob, Button.Ability1);
			mob.MobHasAttacked = true;
		}

		if (AutoAbility2Chance != false && randomChance <= AutoAbility2Chance) {
			if (mob.MobHasAttacked == true) {
				Wait(AttackInterval, WaitBehavior.AbortWhenFalse);
			}
			
			PressButton(mob, Button.Ability2);
			if (HeroMob == Hero.Moira) {
				Wait(1, WaitBehavior.IgnoreCondition);
				PressButton(mob, Button.SecondaryFire);
			}
			mob.MobHasAttacked = true;
		}

		if (AutoPrimaryAtkChance != false && randomChance <= AutoPrimaryAtkChance) {
			if (mob.MobHasAttacked == true) {
				Wait(AttackInterval, WaitBehavior.AbortWhenFalse);
			}

			if (HoldPrimaryFire){
				StartHoldingButton(mob, Button.PrimaryFire);
				Wait(RandomInteger(0.500, 3), WaitBehavior.IgnoreCondition);
				StopHoldingButton(mob, Button.PrimaryFire);
			} else {
				PressButton(mob, Button.PrimaryFire);
			}
			mob.MobHasAttacked = true;
		}

		if (AutoSecondaryAtkChance != false && randomChance <= AutoSecondaryAtkChance) {
			if (mob.MobHasAttacked == true) {
				Wait(AttackInterval, WaitBehavior.AbortWhenFalse);
			}

			if (HoldSecondaryFire){
				StartHoldingButton(mob, Button.SecondaryFire);
				Wait(RandomInteger(0.500, 3), WaitBehavior.IgnoreCondition);
				StopHoldingButton(mob, Button.SecondaryFire);
			} else {
				PressButton(mob, Button.SecondaryFire);
			}
		}
		
		mob.MobHasAttacked = false;
	}
}